---
title: "Code-centered Behavior Code Review"
author: "N.M. Tarr"
date: "2023-12-04"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("~/Code/NCBA/resources")
source("ncba_functions.R")
library(auk)
```

```{r}
# get_breeding_records <- function(database = "AtlasCache", species = NULL, 
#                           observer = NULL, block = NULL, 
#                           project = "EBIRD_ATL_NC", EBD_fields_only = FALSE,
#                           fields = NULL) {

database = "AtlasCache"
behavior = "S7"
observer = NULL
block = NULL
project = "EBIRD_ATL_NC"
EBD_fields_only = FALSE
fields = NULL
  
library(tidyverse)
library(auk)

# SET UP ---------------------------------------------------------------------
# Set the working directory
if (is.null(work_dir) == FALSE) {
  setwd(work_dir)
}

# If a list of fields is provided, set EBD_fields_only to FALSE
if (is.null(fields) == FALSE) {
  EBD_fields_only = FALSE
  
  # and make upper case
  fields <- str_to_upper(fields)
}

# ATLAS CACHE ----------------------------------------------------------------
if (database == "AtlasCache") {
  # Connect to the NCBA database
  connection <- connect_ncba_db("ebd_mgmt", "ebd")
  
  # ---------- QUERY DEFINITION ----------
  # Define a query sequentially.  First, address project
  if (is.null(project) == TRUE) {
    query <- '{}'
  } else {
    query <- str_interp('{"PROJECT_CODE" : "${project}"}')
  }
  
  # Next, address observer
  if (is.null(observer) == FALSE) {
    # Avoid a leading comma
    if (query == '{}') {
      new_end <- str_interp('"OBSERVER_ID" : "${observer}"}')
    } else {
      new_end <- str_interp(', "OBSERVER_ID" : "${observer}"}')
    }
    query <- paste0(substr(query, 1, nchar(query)-1), new_end)
  } else {
    query <- query
  }
  
  # Next, address block id
  if (is.null(block) == FALSE) {
    if (query == '{}') {
      new_end <- str_interp('"ATLAS_BLOCK" : "${block}"}')
    } else {
      new_end <- str_interp(', "ATLAS_BLOCK" : "${block}"}')
    }
    query <- paste0(substr(query, 1, nchar(query)-1), new_end)
  } else {
    query <- query
  }
  
  # Next, address species
  if (is.null(species) == FALSE) {
    if (query == '{}') {
      new_end <- str_interp('"OBSERVATIONS.BEHAVIOR_CODE" : "${behavior}"}')
    } else {
      new_end <- str_interp(', "OBSERVATIONS.BEHAVIOR_CODE" : "${behavior}"}')
    }
    query <- paste0(substr(query, 1, nchar(query)-1), new_end)
  } else {
    query <- query
  }
  
  # ---------- FIELDS ----------
  # Define a fields filter for the desired columns...
  if (is.null(fields) == TRUE) {
    if (EBD_fields_only == TRUE) {
      # Identify AC fields for omission
      AC.fields <- nonEBD_fields()
      
      # Convert the list of field names to a mongolite filter string
      #   this will allow observations field through which then gets unnested
      #   but that is OK because all fields nested within OBSERVATIONS are
      #   EBD fields
      fields2 <- paste0('{', paste0('"', AC.fields, '" : false',
                                    collapse = ', '), '}')
    }
    
    if (EBD_fields_only == FALSE) {
      fields2 <- "{}"
    }
  }
  
  # ... but if fields are provided, use those as a filter
  if (is.null(fields) == FALSE) {
    # Convert the list of field names to a mongolite filter string
    fields_string <- paste0('{', paste0('"', fields, '" : true',
                                        collapse = ', '))
    
    # Redefine fields so that it can be pasted with the filter string
    fields2 <- ', "OBSERVATIONS" : true}'
    
    # Combine with the existing fields string
    fields2 <- paste0(fields_string, fields2)
  }
  
  # ---------- GET RECORDS ----------
  # Retrieve the checklists
  if (is.null(species) == FALSE) {
    records <- connection$find(fields = fields2, query = query) %>%
      unnest(cols = (c(OBSERVATIONS))) %>% # Expands observations
      filter(BEHAVIOR_CODE == behavior) # Rows for non-target species detected along
    # with target species exist and need to be dropped.
  } else {
    records <- connection$find(fields = fields2, query = query) %>%
      unnest(cols = (c(OBSERVATIONS)))
  }
  
  # Second pass at dropping unwanted fields (needed because of nested fields).
  if (is.null(fields) == FALSE) {
    # Get a list of names from fields that are still in the columns of records
    dropem <- intersect(names(records), fields)
    
    # Drop the unwanted columns
    records <- records %>% select(any_of(dropem))
  }
}

# EBIRD BASIC DATASET --------------------------------------------------------
if (database == "EBD") {
  library(auk)
  
  # Condition next action on whether a single species is specified.
  if (is.null(behavior) == FALSE) {
    # Read in sampling data frame with auk
    ebd <- EBD_observations %>%
      auk_ebd() %>%
      auk_breeding() %>%
      auk_filter("TMP_EBD.txt", overwrite = TRUE) %>%
      read_ebd() %>%
      data.frame()
  }
  
  if (is.null(behavior) == TRUE) {
    ebd <- EBD_observations %>%
      auk_ebd() %>%
      auk_filter("TMP_EBD.txt", overwrite = TRUE) %>%
      read_ebd() %>%
      data.frame()
  }
  
  # Pull out desired project
  if (is.null(project) == FALSE) {
    ebd <- filter(ebd, project_code == project)
  }
  
  # Pull out desired block
  if (is.null(block) == FALSE) {
    ebd <- filter(ebd, atlas_block == block)
  }
  
  # Pull out desired observer
  if (is.null(observer) == FALSE) {
    ebd <- filter(ebd, observer_id == observer)
  }
  
  # Subset the columns
  if (is.null(fields) == FALSE) {
    records <- select(ebd, str_to_lower(fields))
  } else {
    records <- ebd
  }
}

```

```{r}
# get_breeding_records <- function(database = "AtlasCache", species = NULL, 
#                           observer = NULL, block = NULL, 
#                           project = "EBIRD_ATL_NC", EBD_fields_only = FALSE,
#                           fields = NULL) {

database = "AtlasCache"
#behavior = '["S7", "ON"]'
behaviors = c("S7", "ON")
observer = NULL
block = NULL
project = "EBIRD_ATL_NC"
EBD_fields_only = FALSE
fields = NULL
  
library(tidyverse)
library(auk)

# SET UP ---------------------------------------------------------------------
# Set the working directory
if (is.null(work_dir) == FALSE) {
  setwd(work_dir)
}

# If a list of fields is provided, set EBD_fields_only to FALSE
if (is.null(fields) == FALSE) {
  EBD_fields_only = FALSE
  
  # and make upper case
  fields <- str_to_upper(fields)
}

# ATLAS CACHE ----------------------------------------------------------------
if (database == "AtlasCache") {
  # Reformat behaviors argument as a string
  behaviors <- paste0('["', paste(behaviors, collapse = '", "'), '"]')
  
  # Connect to the NCBA database
  connection <- connect_ncba_db("ebd_mgmt", "ebd")
  
  # ---------- QUERY DEFINITION ----------
  # Define a query sequentially.  First, address project
  if (is.null(project) == TRUE) {
    query <- '{}'
  } else {
    query <- str_interp('{"PROJECT_CODE" : "${project}"}')
  }
  
  # Next, address observer
  if (is.null(observer) == FALSE) {
    # Avoid a leading comma
    if (query == '{}') {
      new_end <- str_interp('"OBSERVER_ID" : "${observer}"}')
    } else {
      new_end <- str_interp(', "OBSERVER_ID" : "${observer}"}')
    }
    query <- paste0(substr(query, 1, nchar(query)-1), new_end)
  } else {
    query <- query
  }
  
  # Next, address block id
  if (is.null(block) == FALSE) {
    if (query == '{}') {
      new_end <- str_interp('"ATLAS_BLOCK" : "${block}"}')
    } else {
      new_end <- str_interp(', "ATLAS_BLOCK" : "${block}"}')
    }
    query <- paste0(substr(query, 1, nchar(query)-1), new_end)
  } else {
    query <- query
  }
  
  # Next, address species
  if (is.null(species) == FALSE) {
    if (query == '{}') {
      new_end <- str_interp('"OBSERVATIONS.BEHAVIOR_CODE" : { "$in" : ${behaviors} } }')
    } else {
      new_end <- str_interp(', "OBSERVATIONS.BEHAVIOR_CODE" : { "$in" : ${behaviors} } }')
    }
    query <- paste0(substr(query, 1, nchar(query)-1), new_end)
  } else {
    query <- query
  }

  
  # ---------- FIELDS ----------
  # Define a fields filter for the desired columns...
  if (is.null(fields) == TRUE) {
    if (EBD_fields_only == TRUE) {
      # Identify AC fields for omission
      AC.fields <- nonEBD_fields()
      
      # Convert the list of field names to a mongolite filter string
      #   this will allow observations field through which then gets unnested
      #   but that is OK because all fields nested within OBSERVATIONS are
      #   EBD fields
      fields2 <- paste0('{', paste0('"', AC.fields, '" : false',
                                    collapse = ', '), '}')
    }
    
    if (EBD_fields_only == FALSE) {
      fields2 <- "{}"
    }
  }
  
  # ... but if fields are provided, use those as a filter
  if (is.null(fields) == FALSE) {
    # Convert the list of field names to a mongolite filter string
    fields_string <- paste0('{', paste0('"', fields, '" : true',
                                        collapse = ', '))
    
    # Redefine fields so that it can be pasted with the filter string
    fields2 <- ', "OBSERVATIONS" : true}'
    
    # Combine with the existing fields string
    fields2 <- paste0(fields_string, fields2)
  }
  
  # ---------- GET RECORDS ----------
  print(query)
  # Retrieve the checklists #                    IS THIS IF THEN NECESSARY?
  if (is.null(behaviors) == FALSE) {
    records <- connection$find(fields = fields2, query = query) %>%
      unnest(cols = (c(OBSERVATIONS))) %>% # Expands observations
      filter(BEHAVIOR_CODE %in% behaviors) # Rows for non-target species detected along
    # with target species exist and need to be dropped.
  } else {
    records <- connection$find(fields = fields2, query = query) %>%
      unnest(cols = (c(OBSERVATIONS)))
  }
  
  # Second pass at dropping unwanted fields (needed because of nested fields).
  if (is.null(fields) == FALSE) {
    # Get a list of names from fields that are still in the columns of records
    dropem <- intersect(names(records), fields)
    
    # Drop the unwanted columns
    records <- records %>% select(any_of(dropem))
  }
}

# EBIRD BASIC DATASET --------------------------------------------------------
if (database == "EBD") {
  library(auk)
  
  # Condition next action on whether a single species is specified.
  if (is.null(behaviors) == FALSE) {
    # Read in sampling data frame with auk
    ebd <- EBD_observations %>%
      auk_ebd() %>%
      auk_breeding() %>%
      auk_filter("TMP_EBD.txt", overwrite = TRUE) %>%
      read_ebd() %>%
      data.frame()
  }
  
  if (is.null(behaviors) == TRUE) {
    ebd <- EBD_observations %>%
      auk_ebd() %>%
      auk_filter("TMP_EBD.txt", overwrite = TRUE) %>%
      read_ebd() %>%
      data.frame()
  }
  
  # Pull out desired project
  if (is.null(project) == FALSE) {
    ebd <- filter(ebd, project_code == project)
  }
  
  # Pull out desired block
  if (is.null(block) == FALSE) {
    ebd <- filter(ebd, atlas_block == block)
  }
  
  # Pull out desired observer
  if (is.null(observer) == FALSE) {
    ebd <- filter(ebd, observer_id == observer)
  }
  
  # Subset the columns
  if (is.null(fields) == FALSE) {
    records <- select(ebd, str_to_lower(fields))
  } else {
    records <- ebd
  }
}

```

