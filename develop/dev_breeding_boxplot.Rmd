---
title: "Breeding Boxplot Function"
author: "N.M. Tarr"
output: 
  rmdformats::downcute:
  html_document:
    df_print: paged
    code_folding: hide
---
```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE)
```

#Purpose
This document details a function that generates a boxplot of breeding codes with some customization options and supports the ability to view the checklist behind individual data points by clicking on them.  

# Function Definition
```{r}
# ------------------------------------------------------------------------------
breeding_boxplot <- function(species, data, pallet, out_pdf, no_plot_codes,
                             lump, drop, cex.x.axis = 0.9, cex.y.axis = 0.8) {
  # Produces a boxplot of breeding codes over calendar day.
  #
  # Description:
  #   Produces a boxplot of breeding codes with some customization options.  
  #     Copied from the wbbii_tools repo.
  # 
  # Arguments:
  # species -- common name of the species
  # data -- data frame of ebird or NCBA data
  # pallet -- choose a named RColorBrewer pallet (multiple colors), or a single
  #   color (name or hex); see brewer.pal.info for list and 
  #   display.brewer.all() to view all pallets
  # no_plot_codes -- a vector of evidence codes not be plotted. For example, 
  #   c("PE", "UN")
  # lump -- a list of named vectors where the vector name is used to place all
  #   codes in the corresponding vector (e.g. 'S = c("S", "S7", "M")' replaces
  #   all "S", "S7", and "M" with "S"). Note that any code that is not already in
  #   variable "codelevels" in function "chronplot" (below) will need to be added
  #   there.
  # drop -- TRUE or FALSE whether to include unreported codes in the plot
  library(lubridate)
  library(grid)
  library(gridBase)
  library(RColorBrewer)
  
  # Data prep
  ebird <- data # THis should eventually be removed and ebird renamed.
  # put all dates within the same year -- ignores leap year
  ebird$observation_date <- sub("^20\\d\\d", "2016", ebird$observation_date)
  
  # remove white space from evidence codes
  ebird$breeding_code <- trimws(ebird$breeding_code)
  
  # lump evidence codes if lump has been set
  if (is.null("lump") == FALSE) {
    for (i in seq_along(lump)) {
      indx <- ebird$breeding_code %in% lump[[i]]
      ebird[indx, "breeding_code"] <- names(lump)[i]
    }
  }
  
  # remove unneeded evidence codes
  if (is.null("no_plot_codes") == FALSE) {
    ebird <- ebird[! ebird$breeding_code %in% no_plot_codes, ]
  }
  
  # rename columns because ebird names are long
  cols <- c("common_name", "breeding_code", "observation_date")
  newnames <- c("name", "code", "obsdate")
  ebird <- ebird[ebird$common_name == species, cols]
  names(ebird) <- newnames
  
  # make obsdate a date object
  ebird$obsdate <- as.Date(ebird$obsdate, "%Y-%m-%d")
  
  # set order that box plots will be plotted.
  # http://stackoverflow.com/questions/19681586/ordering-bars-in-barplot
  # this will be the order that codes are plotted in.
  # this vector will need updating if any new codes are introduced via "lump".
  codelevels <- c("H", "S", "S7", "M", "T", "P", "C", "B", "CN", "NB", "A", "N",
                  "DD", "ON", "NE", "FS", "CF", "NY", "FY", "FL", "PE", "UN",
                  "F", "", "O", "NC")
  
  if (! all(ebird$code %in% codelevels)) {
    warn <- paste("Not all eBird codes (breeding_code) for",
                  species, "are in codelevels")
    warning(warn)
  }
  
  # associate colors with codelevels
  if (pallet %in% rownames(brewer.pal.info)) {
    n <- brewer.pal.info[pallet, "maxcolors"]
    codecolors <- colorRampPalette(brewer.pal(n, pallet))(length(codelevels))
  } else {
    codecolors <- rep(pallet, length(codelevels))
  }
  
  names(codecolors) <- codelevels
  
  # used droplevels so that codes that where not observed are not plotted;
  # remove droplevels if you'd like unobserved codes to be included on the plot
  if (drop == TRUE) {
    ebird$code <- droplevels(factor(ebird$code, levels = codelevels,
                                    ordered = TRUE))
  } 
  
  # plot "empty" box plot
  boxplot(obsdate ~ code, horizontal = TRUE, cex.axis = cex.y.axis, xaxt = "n",
          data = ebird, border = "white", main = species, las = 2,
          xlab = "Date", ylab = "Breeding Codes", show.names = TRUE)
  
  date0 <- round_date(min(ebird$obsdate), "month")
  date1 <- round_date(max(ebird$obsdate), "month")
  labels <- seq(from = date0, to = date1, by = "month")
  
  if (length(unique(month(ebird$obsdate))) == 1) {
    labels <- c(min(ebird$obsdate), max(ebird$obsdate))
    labels <- unique(labels)  # in case there's only one obs
  } else {
    # limit labels to those within observed range
    int <- interval(min(ebird$obsdate), max(ebird$obsdate))
    labels <- labels[labels %within% int]
    
    if (nrow(ebird) > 1 && length(labels) == 1) {
      labels <- unique(c(min(ebird$obsdate), max(ebird$obsdate)))
    }
  }
  
  # use format "%m/%d" for e.g. 06/01
  # use format "%b %d" for e.g. "Aug 23"
  names(labels) <- format(labels, "%b %d")
  
  vps <- baseViewports()
  pushViewport(vps$inner, vps$figure, vps$plot)
  
  # label x axis; set font size in gpar(cex = relative_fontsize);
  # grid.text is can be hard to follow but allows for arbitrary rotation of
  # x labels
  grid.text(names(labels), x = unit(labels, "native"), y = unit(-0.7, "lines"),
            just = "right", rot = 65, gp = gpar(cex = cex.x.axis))
  popViewport(3)
  
  # add tick marks
  axis(1, labels, labels = FALSE)
  
  # uncomment this to label the x axis a second time for sanity check
  # because grid.text can be difficult to understand
  # axis(1, labels, format(labels, "%m/%d"), col.axis = "red", las = 2)
  
  # select colors for stripchart
  # should be able to use "codecolors[levels(ebird$code)]",  but
  # that's giving an issue matching the empty string...
  col <- codecolors[names(codecolors) %in% levels(ebird$code)]
  
  stripchart(obsdate ~ code, data = ebird, vertical = FALSE, method = "jitter",
             pch = 16, col = col, add = TRUE)
  
  #set boxplot color and partial transparency (where alpha is opacity)
  #run mycol to get the color code, then paste it into the next line
  #mycol <- rgb(245, 245, 245, max = 255, alpha = 0, names = "ltgrayclear")
  #mycol
  
  # plot
  boxplot(obsdate ~ code, horizontal = TRUE,  col = "#F5F5F500", yaxt = "n", 
          xaxt = "n", data = ebird, add = TRUE)
  
  # interactive plot
  # ggiraph code for boxplot and interactive points
  gg_point = ggplot(data = ebird) +
    geom_boxplot(aes(x = obsdate, y = code)) +
    geom_point_interactive(aes(x = obsdate, y = code, color = col, tooltip = datelabelshort, data_id = datelabelshort,
                              onclick=paste0('window.open("', link , '", "_blank")')),
      show.legend = FALSE, position = position_jitter(width = .2, height = .2)) +
    theme_minimal()  + labs(title = comname)
  
  girafe(ggobj = gg_point, width_svg=10, options = list(opts_sizing(rescale = TRUE)))
  
}

```


# Usage
Several packages must be loaded to run this function.
```{r}
#library(dplyr)
#library(tidyr)
library(stringr)
library(tidyverse)
library(ggiraph)
library(ggplot2)
#theme_set(theme_bw())
#library(sf)
#library(RColorBrewer)
#library(maps)
#library(hms)
#library(lubridate)
#library(tmap)
```

Load the NCBA functions because this function relies upon the output from some of them.
```{r}
setwd("~/Code/NCBA/resources")
source("ncba_functions.R")
config <- "~/Documents/NCBA/Scripts/ncba_config.R"
```

Set the working directory to somewhere outside of the NCBA repository so that results are not saved in the repository.
```{r}
setwd("~/Documents/NCBA/species/")
```

Use the NCBA connection function to connect to the Atlas Cache (the mongodb).
```{r}
# connect to a specific collection (table)
connection <- connect_ncba_db(ncba_config = config, database = "ebd_mgmt", 
                              collection = "ebd")
```

Identify a species to investigate.
```{r}
species <- "Willow Flycatcher"
print(species)
```

Retrieve the records for the species from the Atlas Cache
```{r}
time1 <- proc.time()

# execute a query
query <- str_interp('{"OBSERVATIONS.COMMON_NAME":"${species}"}')

nc_data <- connection$find(query) %>%
  unnest(cols = (c(OBSERVATIONS))) %>% # Expand observations
  filter(COMMON_NAME == species)

# format columns to the standard analysis format (ebd format)
records <- to_ebd_format(nc_data, drop=FALSE)

# Calculate processing time
mongotime <- proc.time() - time1

# Print number of records returned
print(paste("Records returned:", nrow(records)))
print(paste("Runtime: ", mongotime[["elapsed"]]))
```

Make a boxplot without lumping codes together
```{r}
breeding_boxplot(species, records, pallet="Paired",
                 no_plot_codes=NULL, lump=NULL, drop=TRUE)
```

Create a boxplot with some of the codes lumped together.
```{r}
lump <- list(S = c("S", "S7", "M"), O = c("", "F", "O", "NC"))

breeding_boxplot(species, records, pallet="Paired",
                 no_plot_codes=NULL, lump=lump, drop=TRUE)
```

Create a boxplot that omits some codes, uses a purple colormap, and saves a pdf version.
```{r}
omit <- c("S", "S7", "M", "O", "NC", "H", "T", "P", "C", "CN", "N", "A", "NB", 
          "FS")
pdf_loc <- "~/Documents/NCBA/test.pdf"
breeding_boxplot(species, records, pallet="Purples",
                 no_plot_codes=omit, lump=NULL, drop=TRUE)
```

