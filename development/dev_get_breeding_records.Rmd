---
title: "dev_get_breeding_records"
author: "N.M. Tarr"
date: "2023-12-5"
output:
  word_document: default
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
setwd("~/Code/NCBA/resources")
source("ncba_functions.R")

knitr::opts_knit$set(root.dir = work_dir)
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE)
```


# Function
Retrieves the observation records with breeding/behavior codes from either the NCBA database or from a downloaded copy of the EBD.  Results can be limited to records with breeding/behavior codes of interest if the Atlas Cache is being queried, but the auk package does not support limiting to specific codes so all records with a breeding code are returned if a copy of the EBD is being queried.  If data is requested from the Atlas Cache, then NCBA columns that are not found in the EBD databases can be dropped or retained.  Additionally, a customized list of fields can be specified to limit the columns that are included in the output data frame.
```{r}
get_breeding_records <- function(database = "AtlasCache", behaviors = NULL, 
                                 observer = NULL, block = NULL, 
                                 project = "EBIRD_ATL_NC", 
                                 EBD_fields_only = FALSE,
                                 fields = NULL) {

  library(tidyverse)
  library(auk)
  
  # SET UP ---------------------------------------------------------------------
  # Set the working directory
  if (is.null(work_dir) == FALSE) {
    setwd(work_dir)
  }
  
  # If a list of fields is provided, set EBD_fields_only to FALSE
  if (is.null(fields) == FALSE) {
    EBD_fields_only = FALSE
    
    # and make upper case
    fields <- str_to_upper(fields)
  }
  
  # Handle condition where behavior codes is NULL
  if (is.null(behaviors) == TRUE) {
    behaviors = breeding_codes(lumped = FALSE)
  }
  
  # ATLAS CACHE ----------------------------------------------------------------
  if (database == "AtlasCache") {
    # Reformat behaviors argument as a string
    behaviors_mongolite <- paste0('["', paste(behaviors, collapse = '", "'), '"]')
  
    # Connect to the NCBA database
    connection <- connect_ncba_db("ebd_mgmt", "ebd")
    
    # ---------- QUERY DEFINITION ----------
    # Define a query sequentially.  First, address project
    if (is.null(project) == TRUE) {
      query <- '{}'
    } else {
      query <- str_interp('{"PROJECT_CODE" : "${project}"}')
    }
    
    # Next, address observer
    if (is.null(observer) == FALSE) {
      # Avoid a leading comma
      if (query == '{}') {
        new_end <- str_interp('"OBSERVER_ID" : "${observer}"}')
      } else {
        new_end <- str_interp(', "OBSERVER_ID" : "${observer}"}')
      }
      query <- paste0(substr(query, 1, nchar(query)-1), new_end)
    } else {
      query <- query
    }
    
    # Next, address block id
    if (is.null(block) == FALSE) {
      if (query == '{}') {
        new_end <- str_interp('"ATLAS_BLOCK" : "${block}"}')
      } else {
        new_end <- str_interp(', "ATLAS_BLOCK" : "${block}"}')
      }
      query <- paste0(substr(query, 1, nchar(query)-1), new_end)
    } else {
      query <- query
    }
    
    # Next, address species
    if (is.null(behaviors) == FALSE) {
      if (query == '{}') {
        new_end <- str_interp('"OBSERVATIONS.BEHAVIOR_CODE" : { "$in" : ${behaviors_mongolite} } }')
      } else {
        new_end <- str_interp(', "OBSERVATIONS.BEHAVIOR_CODE" : { "$in" : ${behaviors_mongolite} } }')
      }
      query <- paste0(substr(query, 1, nchar(query)-1), new_end)
    } else {
      query <- query
    }
  
    
    # ---------- FIELDS ----------
    # Define a fields filter for the desired columns...
    if (is.null(fields) == TRUE) {
      if (EBD_fields_only == TRUE) {
        # Identify AC fields for omission
        AC.fields <- nonEBD_fields()
        
        # Convert the list of field names to a mongolite filter string
        #   this will allow observations field through which then gets unnested
        #   but that is OK because all fields nested within OBSERVATIONS are
        #   EBD fields
        fields2 <- paste0('{', paste0('"', AC.fields, '" : false',
                                      collapse = ', '), '}')
      }
      
      if (EBD_fields_only == FALSE) {
        fields2 <- "{}"
      }
    }
    
    # ... but if fields are provided, use those as a filter
    if (is.null(fields) == FALSE) {
      # Convert the list of field names to a mongolite filter string
      fields_string <- paste0('{', paste0('"', fields, '" : true',
                                          collapse = ', '))
      
      # Redefine fields so that it can be pasted with the filter string
      fields2 <- ', "OBSERVATIONS" : true}'
      
      # Combine with the existing fields string
      fields2 <- paste0(fields_string, fields2)
    }
    
    # ---------- GET RECORDS ----------
    print(query)
    # Retrieve the checklists #
    records <- connection$find(fields = fields2, query = query) %>%
        unnest(cols = (c(OBSERVATIONS))) %>% # Expands observations
        filter(BEHAVIOR_CODE %in% behaviors) # Rows for non-target records detected along
      # with target records exist and need to be dropped.
    
    # Second pass at dropping unwanted fields (needed because of nested fields).
    if (is.null(fields) == FALSE) {
      # Get a list of names from fields that are still in the columns of records
      dropem <- intersect(names(records), fields)
      
      # Drop the unwanted columns
      records <- records %>% select(any_of(dropem))
    }
  }
  
  # EBIRD BASIC DATASET --------------------------------------------------------
  if (database == "EBD") {
    library(auk)
    
    # Condition next action on whether a single species is specified.
    if (is.null(behaviors) == FALSE) {
      # Read in sampling data frame with auk
      ebd <- EBD_observations %>%
        auk_ebd() %>%
        auk_breeding() %>%
        auk_filter("TMP_EBD.txt", overwrite = TRUE) %>%
        read_ebd() %>%
        data.frame()
    }
    
    if (is.null(behaviors) == TRUE) {
      ebd <- EBD_observations %>%
        auk_ebd() %>%
        auk_filter("TMP_EBD.txt", overwrite = TRUE) %>%
        read_ebd() %>%
        data.frame()
    }
    
    # Pull out desired project
    if (is.null(project) == FALSE) {
      ebd <- filter(ebd, project_code == project)
    }
    
    # Pull out desired block
    if (is.null(block) == FALSE) {
      ebd <- filter(ebd, atlas_block == block)
    }
    
    # Pull out desired observer
    if (is.null(observer) == FALSE) {
      ebd <- filter(ebd, observer_id == observer)
    }
    
    # Subset the columns
    if (is.null(fields) == FALSE) {
      records <- select(ebd, str_to_lower(fields))
    } else {
      records <- ebd
    }
  }
  return(records)
}
```

# Usage
The function can target records of a certain species, project, block, or observer, as well as combinations of those four.

## Species
Retrieve observations from the Atlas Cache with the function, but only certain fields.
```{r}
fields <- c("SAMPLING_EVENT_IDENTIFIER", "BEHAVIOR_CODE", 
            "GLOBAL_UNIQUE_IDENTIFIER", "ATLAS_BLOCK")

behaviors <- NULL#c("S7", "ON")

records <- get_breeding_records(behaviors = behaviors, database = "AtlasCache",
                                EBD_fields_only = TRUE,
                                fields = fields)
print(head(records, 5))
```

Retrieve observations from the EBD with the function.
```{r}
obs <- get_observations(species = "American Avocet", database = "EBD")
print(head(obs, 5))
```

## Block
Retrieve observations from a particular block from the Atlas Cache.
```{r}
block <- "35075F4NW"

fields <- c("ATLAS_BLOCK", "SAMPLING_EVENT_IDENTIFIER", "PROJECT_CODE", 
            "GLOBAL_UNIQUE_IDENTIFIER")

obs <- get_observations(block = block, database = "AtlasCache", fields = fields)
print(head(obs, 5))
```

Retrieve observations from the EBD with the function.  THIS IS VERY SLOW.
```{r}
#obs <- get_observations(block = block, database = "EBD", fields = fields)
#print(head(obs, 5))
```

## Observer
Retrieve observations from a particular observer from the Atlas Cache.
```{r}
observer <- "obsr375303"

fields <- c("OBSERVER_ID", "SAMPLING_EVENT_IDENTIFIER", "PROJECT_CODE", 
            "GLOBAL_UNIQUE_IDENTIFIER")

obs <- get_observations(observer = observer, database = "AtlasCache", 
                        fields = fields)
print(head(obs, 5))
```

Retrieve observations from the EBD with the function. THIS IS VERY SLOW.
```{r}
#obs <- get_observations(observer = observer, database = "EBD",
#                        fields = fields)
#print(head(obs, 5))
```

## Project
Retrieve observations from a particular project from the Atlas Cache.
```{r}
fields <- c("PROJECT_CODE", "SAMPLING_EVENT_IDENTIFIER", 
            "GLOBAL_UNIQUE_IDENTIFIER", "COUNTY", "COMMON_NAME")

obs <- get_observations(project = "EBIRD_ATL_VA", 
                        database = "AtlasCache", 
                        fields = fields)
print(head(obs, 5))
```

Retrieve observations from the EBD with the function.  THIS IS VERY SLOW.
```{r}
#obs <- get_observations(project = "EBIRD_ATL_VA", database = "EBD", 
#                        fields = fields)
#print(head(obs, 5))
```

## All options
More than parameter can be utilized.
```{r}
fields <- c("PROJECT_CODE", "SAMPLING_EVENT_IDENTIFIER", 
            "GLOBAL_UNIQUE_IDENTIFIER")

obs.AC <- get_observations(project = "EBIRD_ATL_NC",
                           observer = "obsr375303",
                           species = "American Avocet",
                           block = "35075F4NW",
                           database = "AtlasCache", 
                           fields = fields)
print(head(obs.AC, 5))
```

```{r}
obs.EBD <- get_observations(project = "EBIRD_ATL_NC",
                            observer = "obsr375303",
                            species = "American Avocet",
                            block = "35075F4NW",
                            database = "EBD", 
                            fields = fields)
print(head(obs.EBD, 5))
```


# Tests

## From the Atlas Cache
There should only be one species name in the data frame. If the species' name alone is returned from this chunk, then the test is passed.
```{r}
obs <- get_observations(species = "King Rail", 
                            database = "AtlasCache",
                            project = "EBIRD_ATL_NC",
                            EBD_fields_only = FALSE,
                            fields = NULL)
print(unique(obs$COMMON_NAME))
```

If NCBA_only was set to TRUE, then the PROJECT_CODE field should only contain "EBIRD_ATL_NC".  This chunk returns "EBIRD_ATL_NC" if the test was passed.
```{r}
obs <- get_observations(species = "King Rail", 
                            database = "AtlasCache",
                            project = "EBIRD_ATL_NC",
                            EBD_fields_only = FALSE,
                            fields = NULL)
print(unique(obs$PROJECT_CODE))
```

If a list of fields is provided, then the output data frame should only include the desired columns.  This chunk should return TRUE if the test is passed.
```{r}
fields <- c("SAMPLING_EVENT_IDENTIFIER", "PROJECT_CODE", "GLOBAL_UNIQUE_IDENTIFIER")

obs <- get_observations(species = "King Rail", 
                            database = "AtlasCache",
                            project = "EBIRD_ATL_NC",
                            EBD_fields_only = TRUE,
                            fields = fields)
print(unique(names(obs) == fields))
```

If only fields that are found in the eBird Basic Dataset are wanted, then no NCBA derived columns should be present.  If this chunk returns FALSE, then the test is passed. 

THIS TEST FAILS because of the fields "SUBSPECIES_COMMON_NAME" and "SUBSPECIES_SCIENTIFIC_NAME".  What is their origin?
```{r}
# Get the list of NCBA columns
NCBA.columns <- nonEBD_fields() 

# Get observations
obs <- get_observations(species = "King Rail", 
                            database = "AtlasCache",
                            EBD_fields_only = TRUE)

# Test whether NCBA columns are in the observation data frame
print(unique(NCBA.columns %in% names(obs)))
```

Identify any columns found in an EBD data set that are absent from the output data frame.  "checklist_id" and "age_sex" are expected to be absent because "checklist_id" is not present in observation records and "age_sex" is included in the AtlasCache as "age/sex".
```{r}
# Get an example EBD data frame
input_file <- system.file("extdata/ebd-sample.txt", package = "auk")
# output text file
output_file <- "ebd_filtered_grja.txt"
ebird_data <- input_file %>% 
  # 1. reference file
  auk_ebd() %>% 
  # 2. define filters
  auk_species(species = "Canada Jay") %>% 
  auk_country(country = "Canada") %>% 
  # 3. run filtering
  auk_filter(file = output_file, overwrite = TRUE) %>% 
  # 4. read text file into r data frame
  read_ebd()

# Get the EBD column names
EBD.columns <- names(ebird_data)

# Get a lower case version of the output data frame columns names
our.columns <- str_to_lower(names(obs))

# Is every EBD column in our column list?
print(setdiff(EBD.columns, our.columns))
```

## eBird Basic Dataset
There should only be one species name in the data frame. If the species' name alone is returned from this chunk, then the test is passed.
```{r}
obs <- get_observations(species = "King Rail", 
                            database = "EBD",
                            project = NULL)

print(unique(obs$common_name))
```

If NCBA_only was set to TRUE, then the PROJECT_CODE field should only contain "EBIRD_ATL_NC".  This chunk returns "EBIRD_ATL_NC" if the test was passed.
```{r}
obs <- get_observations(species = "King Rail", 
                            database = "EBD",
                            project = "EBIRD_ATL_NC",
                            EBD_fields_only = FALSE,
                            fields = NULL)
print(unique(obs$project_code))
```

If a list of fields is provided, then the output data frame should only include the desired columns.  This chunk should return TRUE if the test is passed.
```{r}
fields <- c("sampling_event_identifier", "project_code", "global_unique_identifier")

obs <- get_observations(species = "King Rail", 
                            database = "EBD",
                            project = "EBIRD_ATL_NC",
                            fields = fields)
print(unique(names(obs) == fields))
```


# Speed (in seconds)

## Atlas Cache
For a data-poor species
```{r}
# Run the function 5 times and record the runtime
time <- c()
for (i in 1:5) {
  time1 <- proc.time()
  get_observations(species = "King Rail", database = "AtlasCache")
  t <- proc.time() - time1
  time[i] <- t["elapsed"]
}

# Print the descriptive statistics
print(summary(time))
```

For a data-rich species
```{r}
# Run the function 5 times and record the runtime
time <- c()
for (i in 1:5) {
  time1 <- proc.time()
  get_observations(species = "Indigo Bunting", database = "AtlasCache")
  t <- proc.time() - time1
  time[i] <- t["elapsed"]
}

# Print the descriptive statistics
print(summary(time))
```

## EBD
For a data-poor species
```{r}
# Run the function 2 times and record the runtime
time <- c()
for (i in 1:2) {
  time1 <- proc.time()
  get_observations(species = "King Rail", database = "EBD")
  t <- proc.time() - time1
  time[i] <- t["elapsed"]
}

# Print the descriptive statistics
print(summary(time))
```

For a data-rich species
```{r}
# Run the function 2 times and record the runtime
time <- c()
for (i in 1:2) {
  time1 <- proc.time()
  get_observations(species = "Indigo Bunting", database = "EBD")
  t <- proc.time() - time1
  time[i] <- t["elapsed"]
}

# Print the descriptive statistics
print(summary(time))
```